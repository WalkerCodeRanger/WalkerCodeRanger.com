---
layout: post
tags: [JavaScript]
author: "Jeff Walker"
title: "The State of JS Build Tools 2015"
guid: f9fe5876-39f4-4415-b829-464193718e04
final: true
---

I've recently been looking at JavaScript build tools because I am starting a project in [AngularJS](https://angularjs.org).  So of course, I will need a build tool to compile, bundle and minify my scripts and style sheets. Another reason to look into these now is that Visual Studio 2015 will add support for task runners like Grunt and Gulp.

My starting point in this process was the "Gruntfile.js" created for me by the useful scaffolding tool [Yeoman](http://yeoman.io).  Out of the box it came configured to use [Sass](http://sass-lang.com) with SCSS, while I prefer [Less](http://lesscss.org).  So, I looked into what it would take to switch.  The Grunt configuration, for what I considered a fairly typical build, was hefty, weighing in at 450+ lines.  Digging in further, I discovered a number of things I didn't like.  That led me to evaluate other options. Moving on from [Grunt](http://gruntjs.com), I looked at the next most popular option, [Gulp](http://gulpjs.com). Then, I investigated the less common [Broccoli.js](http://broccolijs.com) and [Brunch](http://brunch.io). I briefly considered the obscure [Mimosa](http://mimosa.io) and [Jake](http://jakejs.com), but didn't see anything compelling enough on their websites to make me think they needed to be considered over and above the others.  This posts details my findings.

<section markdown="1">
## Criteria

When considering these JavaScript build tools, I bring a certain perspective and set of expectations.  I'm a .NET web developer who has been using Visual Studio for a long time.  In the past I have worked in Java and C++ and used a number of IDEs. I have some experience with a wide range of build tools including make, msbuild, rake, nant, and psake.  That experience has led me to prefer a polished tool with lots of convention over configuration.  To me, a build tool exists so I can work on my project and should stay out of my way.  I should have to spend a minimal amount of time configuring and debugging the build.  Most IDEs are pretty good in that regard.  You add a file and the IDE just does the right thing based on the file extension (one only occasionally needs to set a few options).

Being a professional web developer, I also expect that a web focused build tool will have lots of support for the complex asset pipelines of modern web apps.  This is an area where Visual Studio definitely falls down.  This is also an interesting and unique requirement for build tools.  Traditional tools like "make" rarely had to deal with situations like this.  Compiling a C++ app is mostly about finding all the source code, compiling and linking.  There was rarely much more to it than that.  For web applications, there are many different kinds of files that must each pass through their own long pipeline of transformations and combinations.  Additionally, the result isn't a single executable, but a large assemblage of files.  That makes the need for good file clean-up much more important.  Finally, developer expectations have risen since the original days of make tools.  Then we were happy to get an executable when we ran the make command. Now, we expect file watching with incremental rebuilds and live browser reloads.

Here is a brief list of the steps/actions I expect will be present in most JavaScript web app builds. Of course, they will vary from project to project and by developer taste.

* Transcompiling JavaScript: CoffeeScript, Dart, Babel, Traceur etc.
* JavaScript Transforms: wrapping in modules or ng-annotate etc.
* Bundling/Concatenation: combining of scripts and styles into multiple files
* Minification: scripts, styles and html
* Source Maps: for both scripts and styles
* CSS Preprocessor: Less, Sass, Stylus etc.
* Style Transforms: Autoprefixer, PostCSS etc.
* Cache Busting: renaming files with a hash to prevent incorrect caching
* Image Optimization
* Compiling Templates: Mustache or HandlebarsJS, Underscore, EJS, Jade etc.
* Copying Assets: html, fav icon etc.
* Watching for Changes
* Incremental Rebuild
* Clean Build: deleting all files at start or preferably cleaning up files as needed
* Injecting References: generating script and style tags that reference the bundled files
* Build Configurations: separate Dev, Test and Prod configuration, for example to not minify html in dev build
* Serve: running a development web server
* Running Unit Tests
* Running JavaScript and CSS Linters: jshint, csslint etc.
* Dependencies: handle dependencies on npm and Bower packages, Browserfy etc.
</section>

<section markdown="1">
## Findings

So what did I find?  There were some common failings in all the build tools.  One was the presumption that npm and Bower package restore were outside the scope of build.  Unlike with an IDE such as Visual Studio that automatically runs Nuget package restore as needed, none of the JS build tools attempts to.  This was often impossible to work around due to the fact that the build tool required it be one of the npm dependencies of your project and would not run until it was restored.  Several of the tools did have plug-ins supporting Bower package restore.  However, almost all examples I saw assumed one would first run `npm install` then `bower install` before building.  They didn't even setup `bower install` as an action triggered by `npm install`.  Another shortcoming of all the tools is the handling of dependencies.  This isn't entirely their fault since the JavaScript ecosystem is still trying to figure out the issue.  Apparently, npm packages work fine in Node.js (though the reason for the deep paths and duplicate packages created in node_modules are beyond me).  But front end packages are not nearly so well thought through.  Unlike a code library, a front-end package has lots of different assets which may be in many different languages, each of which has its own way of referencing one another. Furthermore, depending on the project toolset, the build might need dependencies either before or after compilation. For example, some projects needs the less files of [bootstrap](http://getbootstrap.com/), while others need the compiled css.  So how is one to express and control how those assets are to be brought into the project? Bower isn't the answer if you ask me (at least not yet).  Referencing a front-end package needs to become as simple as referencing an assembly or Nuget package is in .NET.  Until it is, setting up builds involving dependencies will always be a pain.  With that understanding of the shared issues with JavaScript build tools, let's now consider each tool in turn. 
</section>

<section markdown="1">
## Grunt

[Grunt](http://gruntjs.com) seems to be the starting point for many people when it comes to JS Build Tools.  It certainly appears to be the most widely used one.  However, the [GruntJS.com](http://gruntjs.com) website proudly proclaims Grunt as "The JavaScript Task Runner" and I think that is a good description.  Grunt almost doesn't qualify as a build tool.  It really is a system for running a sequence of commands/tasks.  Each Grunt task is a plug-in that represents a tool one might run from the command line.  Each plug-in defines what its configuration in the Gruntfile is named and what the configuration options are.  The fixed section names mean one can't organize or name the configuration in a way that makes sense to them.  Though there are many commonalities in plug-in configuration, in practice you are forced to read the docs of each plug-in to have any idea how to configure it.  That means the otherwise acceptable docs are marred by the often poor and cryptic documentation of individual plug-ins.  Since each plug-in is essentially a command line tool, they each take a set of input files and a set of output files.  To chain together the long asset pipelines commonly needed requires one to manage an ever expanding set of intermediate temp files.  File watching and live reload are manually configured by specifying tasks to run when files matching file name patterns are modified.  The server configuration options are still totally opaque to me.  Incremental builds must be manually setup using [grunt-newer](https://www.npmjs.com/package/grunt-newer-explicit). In practice, that means having a deep understanding of how each task makes use of its various input files and which of the cascading temp files will need to be rebuilt.  All of this manual configuration leads to enormous, inscrutable configuration files.  If you need to run a couple tasks, grunt will be fine for you.  If you need a real web development build tool.  I strongly suggest you look elsewhere.
</section>

<section markdown="1">
## Gulp

[Gulp](http://gulpjs.com) is the hot new tool.  It is rapidly gaining in popularity and there are some justifiable reasons for this.  It recognizes and attempts to handle the primary unique requirement of web build tools, namely the long pipelines.  In Gulp all plug-ins work on streams (well as of today there are still a number that don't, which is very annoying).  This streaming model allows Gulp tasks to be chained together in streams without worrying about or even producing intermediate temporary files. Gulp touts its high performance due to both streams and parallel task running.  Yet, many users have complained that the parallel task execution is confusing and there are plans to extend the configuration to give more control over this.  Personally, I found the parallel task execution very intuitive and feel the proposed cure is worse than the problem.

While streams are a compelling base for a build tool, I ultimately found Gulp lacking.  Since the core configuration options are minimal, the attitude seems to be that little documentation is needed, but I found the documentation inadequate.  Like Grunt, it was necessary to rely on the usually poor documentation of the plug-ins. This was somewhat mitigated by the greater consistency in plug-in usage versus Grunt.  The Gulp authors believe in opinionated software and have some strong opinions when it comes to Gulp plug-ins.  Normally, I appreciate opinionated software, but in this case I have to disagree with the authors' opinions.  They believe that a tool that already supports streaming should not be wrapped in a plug-in, but used directly.  This runs counter to making builds as easy as possible to setup because it requires one to learn and adapt the tools' unique APIs to the Gulp system.  For a peek into the mess this causes, check out the [GitHub issue over the blacklisting of the gulp-browserify plug-in](https://github.com/gulpjs/plugins/issues/47). In it, dozens of users attempt to figure out the correct way of using Browserify. I don't think any quite hit upon the difficult to find [official recipe](https://github.com/gulpjs/gulp/blob/master/docs/recipes/browserify-uglify-sourcemap.md). But note, even that fails to support the important case of streaming files into Browserify.  The whole issue is complicated enough that it takes an [excellent but lengthy blog post to fully explain](https://medium.com/@sogko/gulp-browserify-the-gulp-y-way-bb359b3f9623).  Furthermore, the streaming model becomes confusing for things that don't fit into it, such as cleaning.  Source maps in particular are odd.  I attempted to combine external source maps with [cache busting](https://www.npmjs.com/package/gulp-rev) with a manifest file and [cleaning up old revisions](https://www.npmjs.com/package/gulp-rev) and while the final config was quite short, it took me several hours and [additional plug-ins](https://www.npmjs.com/package/gulp-filter) to get working.  Watching still requires manual configuration and incremental building is quite confusing to setup.  Figuring out how to do anything is made worse by the [plethora of plug-ins](http://gulpjs.com/plugins/) for doing the same task. Finally, while I don't understand the issue myself, I found many discussions of needing to do extra configuration to get reasonable error messages out of Gulp.
</section>

<section markdown="1">
## Broccoli

[Broccoli.js](http://broccolijs.com) is a newer build tool that has been in the works for a while.  It doesn't seem to have much traction yet, but hopefully its inclusion in the [ember command line tool](http://www.ember-cli.com) will change that.  I really like that the developer has [thought through most of the issues](http://www.solitr.com/blog/2014/02/broccoli-first-release/) facing a JavaScript build tool. Support for watch and incremental build is built in so that Broccoli "will figure out by itself which files to watch, and only rebuild those that need rebuilding".  It achieves that through a sophisticated caching system built on top of its core abstraction of file trees. Trees are Broccoli's answer to Gulp streams and are easily chained. To simplify the system, they don't run tasks in parallel like Gulp, but claim that it isn't necessary because performance is still good. I highly recommend you check out the author's [Comparison With Other Build Tools](http://www.solitr.com/blog/2014/02/broccoli-first-release/) (scroll down to section 5).

Despite all these excellent attributes, Broccoli is still very immature and in beta.  It is lacking in the area of documentation.  [The read me](https://github.com/broccolijs/broccoli/blob/master/README.md) boldly states windows support is spotty. The fact that there is little to no source map support was a big issue for me.  It seemed to me that Broccoli wasn't quite ready for prime time, but I'd really like to see it mature and supplant Grunt and Gulp.
</section>

<section markdown="1">
## Brunch

[Brunch](http://brunch.io) has apparently been around for quite a while and yet flown under the radar.  Brunch relies heavily on convention over configuration and assumes your build pipeline will include most of the steps I laid out above.  When you include a plug-in, it is assumed to apply at the logical point in the pipeline and requires little or even no configuration.  This means that a config that might be [600+ lines in Grunt](https://gist.github.com/paulmillr/eb3ae139aadbbb87ab9b#file-grunt-js) or [150+ lines in Gulp](https://gist.github.com/paulmillr/eb3ae139aadbbb87ab9b#file-gulp-js) could end up being [20 lines in Brunch](https://github.com/paulmillr/brunch-with-chaplin/blob/master/brunch-config.coffee). Brunch is written in CoffeeScript and all the examples are in CoffeeScript, but it isn't too hard to translate to JavaScript. It natively supports watching, and incremental compilation with no extra config whatsoever.  There is direct support for Development vs Production builds with different configurations (other build configurations are easily setup). It even wraps JavaScript modules for you automatically (configurable).

With all that, you might think we had found our answer to JavaScript builds.  However, there are always problems.  Despite the lengthy [Guide](https://github.com/brunch/brunch-guide#readme) and the [Docs](https://github.com/brunch/brunch/tree/master/docs), I still found myself wishing for clearer explanations and more examples. I was surprised to find no support for clean builds baked in.  Hopefully, this will be addressed due to the [issue I filed](https://github.com/brunch/brunch/issues/977).  I'm still trying to figure out the right way to run unit tests with Brunch.  The real issue for me was node and Bower packages.  Since Brunch attempts to manage your code more and even wraps JavaScript in modules, it doesn't seem to play well with packages.  They claim support for Bower, but this wasn't well enough documented for me and still didn't seem to quite be right.  It appears these issues are because Brunch pre-dates the widespread use of npm and Bower and they are looking at how they might solve these issues.  In the mean time, be prepared for some awkwardness around that and [around Browserify](https://www.npmjs.com/package/browserify-brunch).  Lastly, as is common with systems focusing on convention over configuration, if you stray off the established path you might have some issues.  For example, I am still trying to figure out exactly how I can get cache busting to apply to assets like images if I am compiling the templates that reference those images.
</section>

<section markdown="1">
## Conclusions

I am disappointed by the state of JavaScript build tools in 2015.  They are very immature and don't seem to be well informed by the long history of build tools for other environments and platforms.  Additionally, their authors don't seem to be sitting down with the goal of really working through all the issues that come up in a build tool and making sure they are handled and the tool is easy to use.  Only two, namely Brunch and Mimosa seem to have set out with the goal of making most builds very simple to setup and not requiring lots of boilerplate configuration.

So which tool would I recommend?  Personally, I am still working with [Brunch](http://brunch.io) to see if it will work for my project. It would be at the top of my list right now (if you like the convention over configuration approach of Brunch, you could also check out [Mimosa](http://mimosa.io)).  However, if you don't mind the large awkward configurations then you might want to select [Gulp](http://gulpjs.com) or even [Grunt](http://gruntjs.com) just for the size of the community around them and the selection of plug-ins (though I haven't had a problem finding the Brunch plug-ins I need). I'm really interested in watching the development of Broccoli and hope it becomes a viable option in the future.  The ultimate answer is likely to be a tool that doesn't even exist today.  Once package dependencies are ironed out correctly, I think we are likely to find all the existing tools don't quite make sense anymore.  Of course, there is no telling how long it will take to get to such a state.
</section>
